## React Element without using JSX

🟦 React.createElement function is used to create React elements without JSX.

// Create a React element using React.createElement

const myElement = React.createElement(
'div', // Type of element (e.g., 'div', 'span', 'h1', etc.)
{ id: 'myDiv' }, // Props for the element (e.g., id, className, etc.)
'Hello, React!' // Children of the element (e.g., text content)
);

// Log the created React element to the console
console.log(myElement);

// Assuming you have a root element in your HTML with the ID 'root'
const rootElement = document.getElementById('root');

// Render the created React element into the root element
ReactDOM.render(myElement, rootElement);

const container = document.getElementById('root'); // Assuming a container with id="root" in your HTML

const root = ReactDOM.createRoot(container);

ReactDOM.createRoot() accepts a DOM container element as an argument. It returns a root object that manages the React component tree within that container.

root.render(element);

🟨root.render() takes a React element as its argument and renders it into the DOM container.
-to render the created React element into the specified root element.

Key points:
🟨🟨🟨🟨🟨

React.createElement() is a fundamental way to create elements in React.
JSX is a more concise and readable way to write elements, but it's translated into React.createElement() calls behind the scenes.
ReactDOM.createRoot() attaches a React application to a DOM container and manages its rendering.

🔆🔆🔆

## What is package.json file

🔆 package.json is an essential file for any Node.js project, providing a structured way to manage dependencies, automate tasks, and share project information.

🔆 It serves as a central repository for project metadata and configuration

🔆 Name, Version ((major.minor.patch)., description, Main (Entry point), scripts, dependencies, Author,
License, devDependencies

## How to Generate a package.json File:

npm init

## What is package-lock.json

🔆 The package-lock.json file is a dependency lock file generated by the Node Package Manager (npm) to ensure that the exact versions of dependencies are installed for a project.

## 🔆 When to Use package-lock.json

🔆 Production Environments: Always use package-lock.json in production environments to ensure consistent and reliable dependency installations.

🔆 Development Environments: While not strictly necessary, using package-lock.json in development environments can help maintain consistency and prevent unexpected issues.

🔆 Dependency Sharing: When sharing dependencies with other developers, provide the package-lock.json file to ensure they install the exact same versions.

🔆 In summary, the package-lock.json file plays a crucial role in maintaining dependency stability, ensuring predictable builds, and promoting collaboration in Node.js development projects.

🔆Purpose:

Deterministic Dependency Resolution:

🔆 The package-lock.json file is designed to lock down the versions of dependencies and their transitive dependencies. This ensures that everyone working on the project gets the exact same dependency tree, avoiding the problem of different developers or CI environments installing slightly different dependency versions.

Faster, Consistent Builds:

🔆 By having a lock file, npm can skip the dependency resolution step when installing packages, making the installation process faster and more consistent.

Key Components:
🔆🔆🔆🔆🔆🔆🔆🔆

Version Information:

The package-lock.json file includes the exact versions of each installed package and its dependencies. This includes not only the direct dependencies listed in the dependencies section of package.json but also all transitive dependencies.

Integrity Check:

The integrity field contains a cryptographic hash of the package contents. This ensures that the installed package matches the one that was originally published on the npm registry, providing a level of security against tampering.

Dependency Hierarchy:

The file includes a detailed hierarchy of dependencies, outlining the relationships between packages and their versions. This hierarchy is crucial for accurately reproducing the dependency tree during installations.

How It Works:
🔆🔆🔆🔆🔆🔆

Installation:
🔆🔆🔆🔆🔆🔆

When you run npm install, npm looks at the package-lock.json file to determine the exact versions of dependencies to install.

Updating Dependencies:
🔆🔆🔆🔆🔆🔆🔆🔆🔆

When you run npm install <package> to update a specific package, npm updates the package-lock.json file with the new version and recalculates the entire dependency tree to ensure version consistency.

Version Control:
🔆🔆🔆🔆🔆🔆🔆

Version Control Best Practices:
It's recommended to include the package-lock.json file in version control to ensure that everyone working on the project gets the same dependency versions.

npm ci:
🔆🔆🔆🔆🔆🔆

The npm ci command is often used in CI/CD environments to install dependencies based on the package-lock.json file. It provides a faster and more reliable way to install dependencies in a clean environment.

# Node Module:

🔆🔆🔆🔆🔆🔆🔆🔆🔆🔆🔆

🟨 Node modules, also known as npm packages, are reusable code libraries that provide specific functionalities

🟨 Enabling developers to quickly and efficiently build complex applications by leveraging existing code and functionalities.

🟨 Dependency Storage:

The node_modules directory is where npm installs and stores project dependencies. Each package has its own subdirectory within node_modules.

🟨 Key Benefits of Using Node Modules for React Developers

Code Reusability:

    Node modules promote code reuse, allowing developers to leverage existing and well-tested code rather than reinventing the wheel.

Enhanced Functionality:

    Node modules provide a wide range of functionalities, from data management and routing to authentication and analytics

Dependency Management:

    Node modules are managed using the Node Package Manager (npm), which simplifies the process of installing, updating, and managing dependencies.

    Essential Node Modules for React Developers
    🔆🔆🔆🔆🔆🔆🔆🔆🔆🔆

    React: The core library for building React applications, providing the components, hooks, and APIs for creating interactive user interfaces.

    React Router: A library for handling routing and navigation in React applications, enabling users to move seamlessly between different sections of the application.

    Redux: A state management library for managing and organizing application state in a predictable and maintainable manner.

    Axios: An HTTP client library for making asynchronous HTTP requests to web servers, enabling data fetching and communication with APIs.

    Styled Components: A library for styling React components using CSS-like syntax, allowing for encapsulating styles within components.

# Ignoring node_modules:

Version Control:

It's common practice to include a .gitignore file to exclude the node_modules directory from version control systems. This is because dependencies can be easily restored by running npm install based on the package.json and package-lock.json files.

Best Practices:
🔆🔆🔆🔆🔆🔆🔆

Use .gitignore:

Always include node_modules in your project's .gitignore file to prevent unnecessary bulk in version control.

Commit package-lock.json:

Commit the package-lock.json file to version control to ensure that the exact dependency versions are used across different environments.

Chapter 02 - Igniting our App

Coding Assignment:
In your existing project
initialize npm into your repo
install react and react-dom
remove CDN links of react
install parcel
ignite your app with parcel
add scripts for “start” and “build” with parcel commands
add .gitignore file
add browserlists
build a production version of your code using parcel build

## Namaste React Course by Akshay Saini

# Chapter 02 - Igniting our App

## Theory Assignment:

- What is `NPM`?
- What is `Parcel/Webpack`? Why `do we need it`?
- What is `.parcel-cache`
- What is `npx` ?
- What is `difference` between `dependencies` vs `devDependencies`
- What is `Tree Shaking`?
- What is `Hot Module Replacement`?
- List down your `favorite 5 superpowers of Parcel` and `describe any 3` of them in your
  own words.
- What is `.gitignore`? What should `we add` and `not add` into it?
- What is the `difference` between `package.json` and `package-lock.json`
- Why should I not modify `package-lock.json`?
- What is `node_modules` ? Is it a `good idea to push that on git`?
- What is the `dist` folder?
- What is `browserlists`
- Read about `dif bundlers`: `vite`, `webpack`, `parcel`
- Read about: `^` - `caret` and `~` - `tilde`
- Read about `Script types in html` (MDN Docs)

## Project Assignment:

- In your `existing project`
  - initialize `npm` into your `repo`
  - install `react` and `react-dom`
  - `remove CDN` links of `react`
  - `install parcel`
  - `ignite your app` with parcel
  - add scripts for `“start”` and `“build”` with `parcel commands`
  - add `.gitignore` file
  - add `browserlists`
  - `build a production version` of your code using `parcel build`

## References:

- [Creating your own create-react-app](https://medium.com/@JedaiSaboteur/creating-a-react-app-from-scratch-f3c693b84658)
- [Parcel Documentation](https://parceljs.org/getting-started/webapp/)
- [Parcel on Production](https://parceljs.org/features/production/)
- [BrowsersList](https://browserslist.dev/)

## Namaste React Course by Akshay Saini

# _Chapter 02 - Igniting our App_

## Q: What is `NPM`?

A: It is a tool used for package management and the default package manager for Node projects. `NPM is installed when NodeJS` is installed on a machine. It comes with a command-line interface (CLI) used to interact with the online database of NPM. This database is called the NPM Registry, and it hosts public and private 'packages.' To add or update packages, we use the NPM CLI to interact with this database.

- `npm` alternative is `yarn`

### How to initialize `npm`?

```
npm init
```

`npm init -y` can be used to skip the setup step, `npm` takes care of it and creates the `package.json` json file automatically , but without configurations.

## Q: What is `Parcel/Webpack`? Why do we need it?

A: `Parcel/Webpack` is type of a web application bundler used for development and productions purposes or power our application with different type functionalities and features.
It offers blazing fast performance utilizing multicore processing, and requires zero configuration. Parcel can take any type of file as an entry point, but an HTML or JavaScript file is a good place to start.
Parcel/Webpack are type of bundlers that we use to power our application with different type functionalities and features.

### Parcel Features:

- HMR (Hot Module Replacement) - parcel keeps track of file changes via file watcher algorithm and renders the changes in the files
- File watcher algorithm - made with C++
- Minification
- Cleaning our code
- DEV and production Build
- Super fast building algorithm
- Image optimization
- Caching while development
- Compresses
- Compatible with older version of browser
- HTTPS in dev
- Port Number
- Consistent hashing algorithm
- Zero Configuration
- Automatic code splitting

### installation commands:

- Install:

```
npm install -D parcel
```

`-D` is used for development and as a development dependency.

- Parcel Commands :
  - For development build:
  ```
  npx parcel <entry_point>
  ```
  - For production build :
  ```
  npx parcel build <entry_point>
  ```

## Q: What is `.parcel-cache`?

A: `.parcel-cache` is used by parcel(bundler) to reduce the building time.
It stores information about your project when parcel builds it, so that when it rebuilds, it doesn't have to re-parse and re-analyze everything from scratch. It's a key reason why parcel can be so fast in development mode.

## Q: What is `npx`?

A: `npx` is a tool that is used to execute the packages. It comes with the npm, when you installed npm above 5.2.0 version then automatically npx will installed. It is an npm package runner that can execute any package that you want from the npm registry without even installing that package.

## Q: What is difference between `dependencies` vs `devDependencies`?

A: `Dependencies` should contain library and framework in which your app is built on, needs to function effectively. such as Vue, React, Angular, Express, JQuery and etc.
`DevDependencies` should contain modules/packages a developer needs during development.
such as, `parcel, webpack, vite, mocha`.
`These packages` are `necessary only while you are developing your project`, not necessary on production.
To save a dependency as a devDependency on installation we need to do,

```
npm install --save-dev
```

instead of just,

```
npm install --save
```

## Q: What is `Tree Shaking`?

A: `Tree shaking` is process of removing the unwanted code that we do not use while developing the application.
In computing, tree shaking is a dead code elimination technique that is applied when optimizing code.

## Q: What is `Hot Module Replacement`?

A: `Hot Module Replacement (HMR)` exchanges, adds, or removes modules while an application is running, without a full reload. This can significantly speed up development in a few ways: Retain application state which is lost during a full reload.

## Q: List down your favorite `5 superpowers of Parcel` and describe any 3 of them in your own words.

A: `5 superpowers of Parcel`:

- `HMR (Hot Module Replacement)` - adds, or removes modules while an application is running, without a full reload.
- `File watcher algorithm` - File Watchers monitor directories on the file system and perform specific actions when desired files appear and track files changes and build once again.
- `Minification` - Minification is the process of minimizing code and markup in your web pages and script files.
- `Image optimization`
- `Caching while development`
- `Local server`
- `Dev build`
- `Image optimization`
- `Code splitting`
- `Important point (Tree shaking)`: remove unused code from your app.
- `Different bundling`: support older browser or cross browser compatability
- `caching`: its provide fasting build using cache.
- `Important point (HTTPS)`: parcel provides https for also localhost. We can check something is working or not with https. read https://parceljs.org/ for best documentation only follow
- `Good Error handling or diagnostic`: it is provide best suggestion for error handling.
- `etc...`: its provide lot of things

## Q: What is `.gitignore`? What should we `add and not add` into it?

A: The `.gitignore file` is a text file that tells `Git` which files or folders to `ignore` in a project during `commit to the repository`.
The types of files you should consider adding to a .gitignore file are any files that do not need to get committed. for example, For security, the security key files and API keys should get added to the gitignore.
`package-lock.json` should `not add` into your `.gitignore` file.

The entries in this file can also follow a matching pattern.

```
* is used as a wildcard match
/ is used to ignore pathnames relative to the .gitignore file
# is used to add comments to a .gitignore file
```

This is an example of what the .gitignore file could look like:

```
# Ignore Mac system files
.DS_store

# Ignore node_modules folder
node_modules

# Ignore all text files
*.txt

# Ignore files related to API keys
.env

# Ignore SASS config files
.sass-cache
```

## Q: What is the difference between `package.json` and `package-lock.json`?

A: `package.json`:

- This file is mandatory for every project
- It contains basic information about the project
- Application name/version/scripts

`package-lock.json`:

- This file is automatically generated for those operations where npm modifies either the node_module tree or package-json.
- It is generated after an npm install
- It allows future devs & automated systems to download the same dependencies as the project.
- it also allows to go back to the past version of the dependencies without actual
  ‘committing the node_modules folder.
- It records the same version of the installed packages which allows to reinstall them.
  Future installs will be capable of building identical description tree.

**~** or **^** in `package.json` file :
These are used with the versions of the package installed.

For example in `package.json` file:

```
"dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
```

- **~** : `Approximately equivalent to version`, will update you to all future patch versions, without incrementing the minor version.
- **^** : `Compatible with version`, will update you to all future minor/patch versions, without incrementing the major version.

> If none of them is present, that means only the version specified in `package.json` file is used in the development.

## Q: Why should I not modify `package-lock.json`?

A: `package-lock.json` file contains the information about the dependencies and their versions used in the project. Deleting it would cause dependencies issues in the production environment. So don't modify it, It's being handled automatically by NPM.

## Q: What is `node_modules` ? Is it a good idea to push that on git?

A: `node_modules` folder like a cache for the external modules that your project depends upon. When you npm install them, they are downloaded from the web and copied into the node_modules folder and Nodejs is trained to look for them there when you import them (without a specific path).
`Don't push node_modules`in github because it contains lots of files(more than 100 MB), it will cost you memory space.

## Q: What is the `dist` folder?

A: The `/dist` folder contains the minimized version of the source code. The code present in the `/dist` folder is actually the code which is used on production web applications. Along with the minified code, the /dist folder also comprises of all the compiled modules that may or may not be used with other systems.

## Q: What is `browserslist`?

A: `Browserslist` is a tool that allows specifying which browsers should be supported in your frontend app by specifying "queries" in a config file. It's used by frameworks/libraries such as React, Angular and Vue, but it's not limited to them.

## Q: What is meening tilde(~) and caret(^) in package.json?

A: always use caret sign in package.json file b/c its is minor changes updated only and tiled (~) use for majro version

like: ~1.2.3 = 2.0.0 major version update
like: ^1.2.3 = 1.2.4 minor version update
